//
// Lam Reference Compiler
// Copyright (C) 2015  Wael El Oraiby
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
// 
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

//
// Note: This file complexity is going to be reduced and the error handling is
//       going to be far improved.
//
%{
open UntypedAst
open System
%}

%start start

%token <ConstSInt64> SINT64
%token <ConstReal64> REAL64
%token <ConstString> STRING
%token <ConstChar>   CHAR
%token <ConstBool>   TRUE
%token <ConstBool>   FALSE

%token <Identifier> IDENTIFIER

%token <TokenInfo>  LEFT_BRACE
%token <TokenInfo>  RIGHT_BRACE
%token <TokenInfo>  LEFT_BRACK
%token <TokenInfo>  RIGHT_BRACK
%token <TokenInfo>  LEFT_PAREN
%token <TokenInfo>  RIGHT_PAREN
%token <TokenInfo>  LEFT_HASH
%token <TokenInfo>  RIGHT_HASH
%token <TokenInfo>  COMMA
%token <TokenInfo>  COL
%token <TokenInfo>  DOT
%token <TokenInfo>  SC
%token <TokenInfo>  YIELD
%token <TokenInfo>  LEQ
%token <TokenInfo>  GEQ
%token <TokenInfo>  EQ
%token <TokenInfo>  SET

%token <TokenInfo>  OP_LAND
%token <TokenInfo>  OP_LOR
%token <TokenInfo>  OP_LNOT

%token <TokenInfo>  OP_ADD
%token <TokenInfo>  OP_SUB
%token <TokenInfo>  OP_MUL
%token <TokenInfo>  OP_DIV
%token <TokenInfo>  OP_MOD

%token <TokenInfo>  OP_AND
%token <TokenInfo>  OP_OR
%token <TokenInfo>  OP_XOR
%token <TokenInfo>  OP_NOT

%token <TokenInfo>  KW_STRUCT
%token <TokenInfo>  KW_RECORD
%token <TokenInfo>  KW_UNION
%token <TokenInfo>  KW_MODULE
%token <TokenInfo>  KW_FN
%token <TokenInfo>  KW_ALIAS
%token <TokenInfo>  KW_OPEN
%token <TokenInfo>  KW_IF
%token <TokenInfo>  KW_ELSE
%token <TokenInfo>  KW_LET

%token EOF
%type <Declaration list>   start
%type <Declaration>        decl
%type <Declaration list>   decl_list

%%

start       : document                      { $1 }

document    : EOF                           { [] }
            | decl_list                     { List.rev $1 }

Struct      : KW_STRUCT identifier LEFT_BRACE field_list RIGHT_BRACE    { Struct ($2, List.rev $4) }
            | KW_STRUCT identifier LEFT_BRACE RIGHT_BRACE               { raise (Exception (sprintf "Structs cannot be empty: struct %s" (fst $2))) }

Record      : KW_RECORD identifier LEFT_BRACE field_list RIGHT_BRACE    { Record ($2, List.rev $4) }
            | KW_RECORD identifier LEFT_BRACE            RIGHT_BRACE    { Record ($2, []) }

Union       : KW_UNION  identifier LEFT_BRACE field_list RIGHT_BRACE    { Union  ($2, List.rev $4) }
            | KW_UNION  identifier LEFT_BRACE            RIGHT_BRACE    { raise (Exception (sprintf "Unions cannot be empty: union %s" (fst $2))) }

Module      : KW_MODULE identifier LEFT_BRACE decl_list  RIGHT_BRACE    { Module ($2, List.rev $4) }
            | KW_MODULE identifier LEFT_BRACE            RIGHT_BRACE    { Module ($2, []) }

Alias       : KW_ALIAS path path                                        { Alias ($2, $3) }

Open        : KW_OPEN path                                              { Open $2 }

decl        : Struct                        { $1 }
            | Record                        { $1 }
            | Union                         { $1 }
            | Module                        { $1 }
            | func                          { $1 }

decl_list   : decl SC                       { [ $1 ] }
            | decl_list decl SC             { $2 :: $1 }

field       : identifier COL atype          { { Field.Identifier = $1; Type = $3 } }
            | identifier COL                { raise (Exception (sprintf "a 'type' is required after '%s :'" (fst $1))) }
            | identifier                    { raise (Exception (sprintf "a ': type' is required after '%s'" (fst $1))) }

field_list  : field SC                      { [ $1 ] }
            | field_list field SC           { $2 :: $1 }

array_type  : path                          { Type.Path (List.rev $1) }
            | array_type LEFT_BRACK RIGHT_BRACK  { Type.Array $1 }
            | LEFT_PAREN func_type RIGHT_PAREN LEFT_BRACK RIGHT_BRACK  { Type.Array (Type.Function $2) }

atype       : array_type                    { $1}
            | func_type                     { Type.Function $1 }

func_type   : LEFT_PAREN fun_args RIGHT_PAREN YIELD atype    { (List.rev $2, $5) }

fun_args    : field                         { [ $1 ] }
            | fun_args COMMA field          { $3 :: $1 }


identifier  : IDENTIFIER                    { $1 }

path        : identifier                    { [ $1 ] }
            | path DOT identifier           { $3 :: $1 }

func        : KW_FN identifier func_type LEFT_BRACE func_body RIGHT_BRACE { Declaration.Function ($2, $3, $5) }

func_body   : expr_list                     { List.rev $1 }

// expressions
expr_list   : expr SC                       { [ $1 ] }
            | expr_list expr SC             { $2 :: $1 }

constant    : SINT64                        { Expr.SInt64 $1 }

primary_exp : identifier                    { Expr.Apply (Expr.Identifier $1, []) }
            | constant                      { $1 }
            | LEFT_PAREN expr RIGHT_PAREN   { $2 }

postfix_exp : primary_exp                   { $1 }
            | postfix_exp LEFT_BRACK expr RIGHT_BRACK { Expr.Item ($1, $3) }
            | postfix_exp arg_list          { Expr.Apply ($1, List.rev $2) }
            | postfix_exp DOT identifier    { Expr.Access ($1, $3) }

tuple_arg_list : expr                       { [ $1 ] }
            | tuple_arg_list COMMA expr     { $3 :: $1 }

tuple       : LEFT_PAREN tuple_arg_list RIGHT_PAREN { Expr.Tuple (List.rev $2) }
           
arg_list    : expr                          { [ $1 ] }
            | tuple                         { [ $1 ] }
            | arg_list COMMA expr           { $3 :: $1 }
            | arg_list COMMA tuple          { $3 :: $1 }

expr        : KW_IF LEFT_PAREN expr RIGHT_PAREN LEFT_BRACE expr_list RIGHT_BRACE KW_ELSE LEFT_BRACE expr_list RIGHT_BRACE
                                            { Expr.If ($3, $6, $10, $1) }
            | postfix_exp                   { $1 }

//            | op_expr                       { $1 }
//            | identifier                    { Expr.Apply (IdentOrOp.Identifier $1, [], snd $1) }

//op_expr     : expr                          { $1 }
//            | op_expr OP_ADD op_expr        { Expr.Apply (IdentOrOp.OpAdd, [ $1; $3 ], $2) }
//            | op_expr OP_SUB op_expr        { Expr.Apply (IdentOrOp.OpSub, [ $1; $3 ], $2) }
//            | op_expr OP_MUL op_expr        { Expr.Apply (IdentOrOp.OpMul, [ $1; $3 ], $2) }
//            | op_expr OP_DIV op_expr        { Expr.Apply (IdentOrOp.OpDiv, [ $1; $3 ], $2) }

