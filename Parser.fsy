//
// Lam Reference Compiler
// Copyright (C) 2015  Wael El Oraiby
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
// 
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

//
// Note: This file complexity is going to be reduced and the error handling is
//       going to be far improved.
//
%{
open UntypedAst
open System
%}

%start start

%token <Expr> SINT64
%token <Expr> REAL64
%token <Expr> STRING
%token <Expr> CHAR
%token <Expr> TRUE
%token <Expr> FALSE

%token <Identifier> IDENTIFIER

%token <TokenInfo>  LEFT_BRACE
%token <TokenInfo>  RIGHT_BRACE
%token <TokenInfo>  LEFT_BRACK
%token <TokenInfo>  RIGHT_BRACK
%token <TokenInfo>  LEFT_PAREN
%token <TokenInfo>  RIGHT_PAREN
%token <TokenInfo>  LEFT_HASH
%token <TokenInfo>  RIGHT_HASH
%token <TokenInfo>  COMMA
%token <TokenInfo>  COL
%token <TokenInfo>  DOT
%token <TokenInfo>  SC
%token <TokenInfo>  YIELD
%token <TokenInfo>  KW_STRUCT
%token <TokenInfo>  KW_RECORD
%token <TokenInfo>  KW_UNION
%token <TokenInfo>  KW_MODULE
%token <TokenInfo>  KW_FN
%token <TokenInfo>  KW_ALIAS
%token <TokenInfo>  KW_OPEN
%token <TokenInfo>  KW_IF
%token <TokenInfo>  KW_ELSE
%token <TokenInfo>  KW_LET

%token EOF
%type <Declaration list>   start
%type <Declaration>        decl
%type <Declaration list>   decl_list

%%

start       : document                      { $1 }

document    : EOF                           { [] }
            | decl_list                     { List.rev $1 }

Struct      : KW_STRUCT identifier LEFT_BRACE field_list RIGHT_BRACE    { Struct ($2, List.rev $4) }
            | KW_STRUCT identifier LEFT_BRACE RIGHT_BRACE               { raise (Exception (sprintf "Structs cannot be empty: struct %s" (fst $2))) }

Record      : KW_RECORD identifier LEFT_BRACE field_list RIGHT_BRACE    { Record ($2, List.rev $4) }
            | KW_RECORD identifier LEFT_BRACE            RIGHT_BRACE    { Record ($2, []) }

Union       : KW_UNION  identifier LEFT_BRACE field_list RIGHT_BRACE    { Union  ($2, List.rev $4) }
            | KW_UNION  identifier LEFT_BRACE            RIGHT_BRACE    { raise (Exception (sprintf "Unions cannot be empty: union %s" (fst $2))) }

Module      : KW_MODULE identifier LEFT_BRACE decl_list  RIGHT_BRACE    { Module ($2, List.rev $4) }
            | KW_MODULE identifier LEFT_BRACE            RIGHT_BRACE    { Module ($2, []) }

Alias       : KW_ALIAS path path                                        { Alias ($2, $3) }

Open        : KW_OPEN path                                              { Open $2 }

decl        : Struct                        { $1 }
            | Record                        { $1 }
            | Union                         { $1 }
            | Module                        { $1 }
            | func                          { $1 }

decl_list   : decl SC                       { [ $1 ] }
            | decl_list decl SC             { $2 :: $1 }

field       : identifier COL atype          { { Field.Identifier = $1; Type = $3 } }
            | identifier COL                { raise (Exception (sprintf "a 'type' is required after '%s :'" (fst $1))) }
            | identifier                    { raise (Exception (sprintf "a ': type' is required after '%s'" (fst $1))) }

field_list  : field SC                      { [ $1 ] }
            | field_list field SC           { $2 :: $1 }

array_type  : atype LEFT_BRACK RIGHT_BRACK  { Type.Array $1 }

atype       : path                          { Type.Path (List.rev $1) }
            | array_type                    { $1}
            | func_type                     { Type.Function $1 }

func_type   : LEFT_PAREN fun_args RIGHT_PAREN YIELD atype    { (List.rev $2, $5) }

fun_args    : field                         { [ $1 ] }
            | fun_args COMMA field          { $3 :: $1 }


identifier  : IDENTIFIER                    { $1 }

path        : identifier                    { [ $1 ] }
            | path DOT identifier           { $3 :: $1 }

func        : KW_FN identifier func_type LEFT_BRACE func_body RIGHT_BRACE { Declaration.Function ($2, $3, $5) }

// expressions
func_body   : expr_list                     { List.rev $1 }

expr_list   :                               { [] }
            | expr SC                       { [ $1 ] }
            | expr_list expr SC             { $2 :: $1 }

expr        : KW_IF LEFT_PAREN expr RIGHT_PAREN LEFT_BRACE expr_list RIGHT_BRACE KW_ELSE LEFT_BRACE expr_list RIGHT_BRACE
                                            { Expr.If ($3, $6, $10, $1) }
 